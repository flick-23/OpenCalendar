import { Actor, HttpAgent, type Identity } from '@dfinity/agent';

// This type should be imported from the .did.js file generated by dfx
// For example: import { idlFactory as userRegistryIdlFactory } from '$declarations/user_registry/user_registry.factory.js';
// We'll use a generic IDL factory type for now.
type IdlFactory = ({ IDL }: { IDL: any }) => any; // Simplified type

// Define a generic interface for actors this function might create.
// Replace `any` with more specific actor method signatures if possible,
// or use this as a base for more specific typed actors.
export type GenericActor = ActorSubclass<any>;

interface CreateActorOptions {
  agentOptions?: {
    identity?: Identity;
    host?: string; // e.g., https://ic0.app or http://localhost:8000 for local dev
  };
  actorOptions?: {
    canisterId: string;
  };
}

/**
 * Creates an actor for interacting with a canister.
 * @param canisterId The ID of the canister to interact with.
 * @param idlFactory The IDL factory for the canister's interface (from .did.js file).
 * @param identity Optional identity to use for authenticated calls. If not provided,
 *                 calls will be anonymous.
 * @param host The host to connect to. Defaults to the appropriate IC or local network.
 * @returns An actor instance.
 */
export const createActor = async <T = GenericActor>(
  canisterId: string,
  idlFactory: IdlFactory, // This will come from the generated files
  identity?: Identity | null,
  host?: string
): Promise<T> => {
  const currentHost = host || (process.env.DFX_NETWORK === 'ic'
    ? 'https://icp-api.io' // Or 'https://ic0.app' or other gateway
    : 'http://localhost:4943'); // Default local replica port from dfx

  const agent = new HttpAgent({
    host: currentHost,
    identity: identity || undefined, // Pass undefined for anonymous identity
  });

  // Fetch root key for local development network if not on 'ic'
  if (process.env.DFX_NETWORK !== 'ic') {
    try {
      await agent.fetchRootKey();
    } catch (error) {
      console.warn('Unable to fetch root key. Ensure local replica is running or network is "ic".', error);
      // Depending on the use case, you might want to throw this error
      // or allow it to proceed if anonymous calls don't strictly need it.
    }
  }

  // Creates an actor with the an interface from the IDL factory.
  const actor = Actor.createActor(idlFactory, {
    agent,
    canisterId,
  });

  return actor as T;
};

// Example of how you might create specific actors:
// (These would typically be in their own files or a central actor registry)

/*
import { idlFactory as userRegistryIdl, canisterId as userRegistryCanisterId } from '$declarations/user_registry';
// import type { _SERVICE as UserRegistryService } from '$declarations/user_registry/user_registry.did';

export const getUserRegistryActor = async (identity?: Identity | null): ActorSubclass<UserRegistryService> => {
    // Ensure canisterId is correctly resolved (from .dfx or env)
    if (!userRegistryCanisterId) {
        throw new Error("User Registry Canister ID not found. Ensure it's in declarations or environment.");
    }
    return createActor<UserRegistryService>(userRegistryCanisterId, userRegistryIdl, identity);
};

import { idlFactory as calendarCanisterIdl, canisterId as calendarCanisterId } from '$declarations/calendar_canister_1';
// import type { _SERVICE as CalendarCanisterService } from '$declarations/calendar_canister_1/calendar_canister_1.did';

export const getCalendarCanisterActor = async (identity?: Identity | null): ActorSubclass<CalendarCanisterService> => {
    if (!calendarCanisterId) {
        throw new Error("Calendar Canister ID not found.");
    }
    return createActor<CalendarCanisterService>(calendarCanisterId, calendarCanisterIdl, identity);
};
*/

// Note: The $declarations alias needs to be configured in svelte.config.js and tsconfig.json
// For now, the createActor function is generic. Specific actor creation functions
// would use the generated IDL factories and canister IDs.
// The `authStore.ts` will need to be updated to use this `createActor` function
// once the actual IDL factories are available after running `dfx generate`.
// Since `dfx generate` hasn't been run yet (as it's usually part of `dfx deploy` or a manual step),
// we are defining the structure here.
// The actual canister IDs (e.g., USER_REGISTRY_CANISTER_ID in authStore) also come from these generated files or env variables.

// For now, this file provides the core `createActor` utility.
// The commented-out sections show how it would be used with generated types.
// The `authStore.ts` was written with a placeholder for `createActor` and canister ID.
// It will need to be updated to:
// 1. Import the actual `idlFactory` for `user_registry`.
// 2. Import the actual `canisterId` for `user_registry`.
// 3. Call `createActor(userRegistryCanisterId, userRegistryIdlFactory, identity)`.
// This update will happen after the backend canisters are deployed and `dfx generate` is run.
// For now, the structure is in place.
console.log("actors.ts loaded. Ensure $declarations are generated and paths are correct for IDL factories.");
