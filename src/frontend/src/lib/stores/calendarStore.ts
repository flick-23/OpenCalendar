import { writable, type Writable, get } from 'svelte/store';
import { authStore }_from '$lib/stores/authStore';
import { createActor } from '$lib/actors/actors';

// Import IDL and canister ID for calendar_canister_1
// These will be generated by `dfx generate`. For now, we define placeholders.
// import { idlFactory as calendarIdlFactory, canisterId as calendarCanisterId } from '$declarations/calendar_canister_1';
// import type { _SERVICE as CalendarService, Event as BackendEvent, Calendar as BackendCalendar } from '$declarations/calendar_canister_1/calendar_canister_1.did';

// Placeholder types until actual declarations are available
type ActorIdentity = any; // from @dfinity/agent Identity
type CalendarId = string | number; // Nat on backend
type EventId = string | number; // Nat on backend
type Timestamp = bigint; // Int on backend (nanoseconds)

// Frontend Event type (mirrors BackendEvent but uses Date for times)
export interface AppEvent {
  id: EventId;
  calendarId: CalendarId;
  title: string;
  description: string;
  startTime: Date;
  endTime: Date;
  color: string;
}

// Frontend Calendar type
export interface AppCalendar {
  id: CalendarId;
  owner: string; // Principal text
  name: string;
  color: string;
}

// --- Placeholder for Backend Types (until $declarations are ready) ---
interface BackendEvent {
  id: EventId;
  calendarId: CalendarId;
  title: string;
  description: string;
  startTime: Timestamp; // Nanoseconds
  endTime: Timestamp;   // Nanoseconds
  color: string;
}
interface BackendCalendar {
 id: CalendarId;
 owner: any; // Principal type from backend
 name: string;
 color: string;
}
interface CalendarService {
  create_event: (event: {
    calendarId: CalendarId;
    title: string;
    description: string;
    startTime: Timestamp;
    endTime: Timestamp;
    color: string;
  }) => Promise<BackendEvent>;
  get_events_for_range: (calendarId: CalendarId, start: Timestamp, end: Timestamp) => Promise<BackendEvent[]>;
  update_event: (eventId: EventId, newData: Partial<Omit<BackendEvent, 'id' | 'calendarId'>>) => Promise<BackendEvent>;
  delete_event: (eventId: EventId) => Promise<boolean>;
  // Methods for calendars - assuming they are in this canister for now or user_registry
  // get_my_calendars: () => Promise<BackendCalendar[]>; // Example
  // create_calendar: (name: string, color: string) => Promise<BackendCalendar>; // Example
}
// --- End Placeholder Types ---

// This will be the actual canister ID from dfx.json or generated files.
const CALENDAR_CANISTER_ID = process.env.CANISTER_ID_CALENDAR_CANISTER_1 || 'bd3sg-teaaa-aaaaa-qaaba-cai'; // Replace with actual ID

// Placeholder IDL factory
const placeholderIdlFactory = ({ IDL } : any) => {
  return IDL.Service({
    'create_event': IDL.Func([IDL.Record({
        'calendarId': IDL.Nat, // Assuming Nat, adjust if different
        'title': IDL.Text,
        'description': IDL.Text,
        'startTime': IDL.Int,
        'endTime': IDL.Int,
        'color': IDL.Text,
    })], [IDL.Record({ /* Define BackendEvent structure here */ })], []),
    'get_events_for_range': IDL.Func([IDL.Nat, IDL.Int, IDL.Int], [IDL.Vec(IDL.Record({ /* BackendEvent */ }))], ['query']),
    'update_event': IDL.Func([IDL.Nat, IDL.Record({ /* Partial BackendEvent */ })], [IDL.Record({ /* BackendEvent */ })], []),
    'delete_event': IDL.Func([IDL.Nat], [IDL.Bool], []),
  });
};


interface CalendarState {
  events: AppEvent[];
  calendars: AppCalendar[]; // User's own calendars or those they have access to
  isLoading: boolean;
  error: string | null;
  selectedCalendarId: CalendarId | null; // To filter events or for new event creation
}

const initialState: CalendarState = {
  events: [],
  calendars: [
    // Example default calendar until backend integration for calendars is complete
    { id: 'default_cal_1', owner: 'system', name: 'My Calendar', color: 'blue' }
  ],
  isLoading: false,
  error: null,
  selectedCalendarId: 'default_cal_1', // Default to the first calendar
};

const transformBackendEventToAppEvent = (backendEvent: BackendEvent): AppEvent => {
  return {
    ...backendEvent,
    startTime: new Date(Number(backendEvent.startTime / 1000000n)), // Convert nanoseconds to milliseconds
    endTime: new Date(Number(backendEvent.endTime / 1000000n)),   // Convert nanoseconds to milliseconds
  };
};

const transformAppEventToBackendParams = (appEventData: Partial<AppEvent> & { calendarId: CalendarId }) => {
  return {
    calendarId: appEventData.calendarId, // Ensure this is passed for new events
    title: appEventData.title || "",
    description: appEventData.description || "",
    // Convert Date to nanoseconds (BigInt for Motoko Int)
    startTime: appEventData.startTime ? BigInt(appEventData.startTime.getTime() * 1000000) : 0n,
    endTime: appEventData.endTime ? BigInt(appEventData.endTime.getTime() * 1000000) : 0n,
    color: appEventData.color || "blue",
  };
};


export const calendarStore: Writable<CalendarState> & {
  fetchEvents: (calendarId: CalendarId, start: Date, end: Date) => Promise<void>;
  createEvent: (eventData: Omit<AppEvent, 'id'>) => Promise<AppEvent | null>;
  updateEvent: (eventId: EventId, eventData: Partial<Omit<AppEvent, 'id' | 'calendarId'>>) => Promise<AppEvent | null>;
  deleteEvent: (eventId: EventId) => Promise<boolean>;
  setSelectedCalendar: (calendarId: CalendarId) => void;
  // TODO: Add methods for fetching/managing calendars when user_registry/calendar canister interaction for calendars is fleshed out
} = (() => {
  const store = writable<CalendarState>(initialState);

  const getCalendarActor = async (): Promise<CalendarService | null> => {
    const auth = get(authStore);
    if (!auth.identity) {
      store.update(s => ({ ...s, error: "User not authenticated" }));
      return null;
    }
    try {
      // Replace placeholderIdlFactory with actual calendarIdlFactory once generated
      return await createActor<CalendarService>(CALENDAR_CANISTER_ID, placeholderIdlFactory, auth.identity);
    } catch (err) {
      console.error("Failed to create calendar actor:", err);
      store.update(s => ({ ...s, error: "Failed to connect to calendar service" }));
      return null;
    }
  };

  return {
    subscribe: store.subscribe,
    set: store.set,
    update: store.update,

    setSelectedCalendar: (calendarId: CalendarId) => {
      store.update(s => ({ ...s, selectedCalendarId: calendarId }));
      // Optionally, auto-fetch events for the newly selected calendar for a default range
      // const today = new Date();
      // const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
      // const endOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0);
      // this.fetchEvents(calendarId, startOfMonth, endOfMonth);
    },

    fetchEvents: async (calendarId: CalendarId, start: Date, end: Date) => {
      store.update(s => ({ ...s, isLoading: true, error: null }));
      const actor = await getCalendarActor();
      if (!actor) return;

      try {
        const startTimeNano = BigInt(start.getTime() * 1000000);
        const endTimeNano = BigInt(end.getTime() * 1000000);

        console.log(`Fetching events for calendar ${calendarId} from ${start.toISOString()} to ${end.toISOString()}`);
        // const backendEvents = await actor.get_events_for_range(calendarId, startTimeNano, endTimeNano);

        // MOCK IMPLEMENTATION until canister is deployable and `dfx generate` ran
        console.warn("calendarStore.fetchEvents is currently mocked.");
        const backendEvents: BackendEvent[] = get(store).events
            .filter(e => e.calendarId === calendarId && e.startTime >= start && e.endTime <= end)
            .map(e => ({
                ...e,
                startTime: BigInt(e.startTime.getTime() * 1000000),
                endTime: BigInt(e.endTime.getTime() * 1000000),
            }));
        // END MOCK

        const appEvents = backendEvents.map(transformBackendEventToAppEvent);
        store.update(s => ({ ...s, events: appEvents, isLoading: false }));
      } catch (err: any) {
        console.error("Error fetching events:", err);
        store.update(s => ({ ...s, error: err.message || "Failed to fetch events", isLoading: false }));
      }
    },

    createEvent: async (eventData: Omit<AppEvent, 'id'>) => {
      store.update(s => ({ ...s, isLoading: true, error: null }));
      const actor = await getCalendarActor();
      if (!actor) return null;

      try {
        const params = transformAppEventToBackendParams(eventData);
        console.log("Creating event with params:", params);
        // const backendEvent = await actor.create_event(params);

        // MOCK IMPLEMENTATION
        console.warn("calendarStore.createEvent is currently mocked.");
        const backendEvent : BackendEvent = {
            ...params,
            id: `mock_id_${Date.now()}`, // Generate a mock ID
        };
        // END MOCK

        const newAppEvent = transformBackendEventToAppEvent(backendEvent);
        store.update(s => ({
          ...s,
          events: [...s.events, newAppEvent],
          isLoading: false
        }));
        return newAppEvent;
      } catch (err: any) {
        console.error("Error creating event:", err);
        store.update(s => ({ ...s, error: err.message || "Failed to create event", isLoading: false }));
        return null;
      }
    },

    updateEvent: async (eventId: EventId, eventData: Partial<Omit<AppEvent, 'id' | 'calendarId'>>) => {
      store.update(s => ({ ...s, isLoading: true, error: null }));
      const actor = await getCalendarActor();
      if (!actor) return null;

      try {
        const backendEventData: Partial<Omit<BackendEvent, 'id' | 'calendarId'>> = {};
        if (eventData.title !== undefined) backendEventData.title = eventData.title;
        if (eventData.description !== undefined) backendEventData.description = eventData.description;
        if (eventData.startTime !== undefined) backendEventData.startTime = BigInt(eventData.startTime.getTime() * 1000000);
        if (eventData.endTime !== undefined) backendEventData.endTime = BigInt(eventData.endTime.getTime() * 1000000);
        if (eventData.color !== undefined) backendEventData.color = eventData.color;

        console.log(`Updating event ${eventId} with data:`, backendEventData);
        // const updatedBackendEvent = await actor.update_event(eventId, backendEventData);

        // MOCK IMPLEMENTATION
        console.warn("calendarStore.updateEvent is currently mocked.");
        const existingEvent = get(store).events.find(e => e.id === eventId);
        if (!existingEvent) throw new Error("Mock event not found for update");
        const updatedBackendEvent : BackendEvent = {
            ...existingEvent,
            ...eventData, // Apply changes
            // Ensure times are BigInt if they were changed
            startTime: eventData.startTime ? BigInt(eventData.startTime.getTime() * 1000000) : BigInt(existingEvent.startTime.getTime() * 1000000),
            endTime: eventData.endTime ? BigInt(eventData.endTime.getTime() * 1000000) : BigInt(existingEvent.endTime.getTime() * 1000000),
            calendarId: existingEvent.calendarId, // Calendar ID cannot change here
        };
        // END MOCK

        const updatedAppEvent = transformBackendEventToAppEvent(updatedBackendEvent);
        store.update(s => ({
          ...s,
          events: s.events.map(e => e.id === eventId ? updatedAppEvent : e),
          isLoading: false
        }));
        return updatedAppEvent;
      } catch (err: any) {
        console.error("Error updating event:", err);
        store.update(s => ({ ...s, error: err.message || "Failed to update event", isLoading: false }));
        return null;
      }
    },

    deleteEvent: async (eventId: EventId) => {
      store.update(s => ({ ...s, isLoading: true, error: null }));
      const actor = await getCalendarActor();
      if (!actor) return false;

      try {
        console.log(`Deleting event ${eventId}`);
        // const success = await actor.delete_event(eventId);

        // MOCK IMPLEMENTATION
        console.warn("calendarStore.deleteEvent is currently mocked.");
        const success = true;
        // END MOCK

        if (success) {
          store.update(s => ({
            ...s,
            events: s.events.filter(e => e.id !== eventId),
            isLoading: false
          }));
        } else {
          store.update(s => ({ ...s, error: "Failed to delete event on backend", isLoading: false }));
        }
        return success;
      } catch (err: any) {
        console.error("Error deleting event:", err);
        store.update(s => ({ ...s, error: err.message || "Failed to delete event", isLoading: false }));
        return false;
      }
    }
  };
})();

// Initialize with some mock data if running in a non-ICP environment or for testing
// This should be removed or conditional for production builds.
if (process.env.NODE_ENV === 'development' && typeof window !== 'undefined') {
  const today = new Date();
  const tomorrow = new Date(today);
  tomorrow.setDate(today.getDate() + 1);
  const nextDay = new Date(today);
  nextDay.setDate(today.getDate() + 2);

  calendarStore.update(s => ({
    ...s,
    events: [
      {
        id: 'evt1', calendarId: 'default_cal_1', title: 'Team Meeting', description: 'Weekly sync',
        startTime: new Date(today.setHours(10, 0, 0, 0)),
        endTime: new Date(today.setHours(11, 0, 0, 0)),
        color: 'purple'
      },
      {
        id: 'evt2', calendarId: 'default_cal_1', title: 'Lunch with Alex', description: '',
        startTime: new Date(today.setHours(13, 0, 0, 0)),
        endTime: new Date(today.setHours(14, 0, 0, 0)),
        color: 'green'
      },
      {
        id: 'evt3', calendarId: 'default_cal_1', title: 'Project Deadline', description: 'Submit phase 1',
        startTime: new Date(tomorrow.setHours(17, 0, 0, 0)),
        endTime: new Date(tomorrow.setHours(17, 30, 0, 0)),
        color: 'red'
      },
       {
        id: 'evt4', calendarId: 'default_cal_1', title: 'Gym Session', description: 'Leg day',
        startTime: new Date(nextDay.setHours(8,0,0,0)),
        endTime: new Date(nextDay.setHours(9,0,0,0)),
        color: 'orange'
      }
    ]
  }));
}

// Auto-fetch events for the current month of selected calendar when store initializes and auth is ready
// authStore.subscribe(auth => {
//   if (auth.isLoggedIn && !auth.isLoading) {
//     const { selectedCalendarId } = get(calendarStore);
//     if (selectedCalendarId) {
//       const { currentCalendarViewDate } = get(uiStore); // Use UI store's date
//       const startOfMonth = new Date(currentCalendarViewDate.getFullYear(), currentCalendarViewDate.getMonth(), 1);
//       const endOfMonth = new Date(currentCalendarViewDate.getFullYear(), currentCalendarViewDate.getMonth() + 1, 0);
//       calendarStore.fetchEvents(selectedCalendarId, startOfMonth, endOfMonth);
//     }
//   }
// });

// Also, react to changes in currentCalendarViewDate from uiStore
// uiStore.subscribe(ui => {
//   const { selectedCalendarId } = get(calendarStore);
//   const { isLoggedIn } = get(authStore);
//   if (isLoggedIn && selectedCalendarId && ui.currentCalendarViewDate) {
//     const startOfMonth = new Date(ui.currentCalendarViewDate.getFullYear(), ui.currentCalendarViewDate.getMonth(), 1);
//     const endOfMonth = new Date(ui.currentCalendarViewDate.getFullYear(), ui.currentCalendarViewDate.getMonth() + 1, 0);
//     calendarStore.fetchEvents(selectedCalendarId, startOfMonth, endOfMonth);
//   }
// });

console.log("calendarStore.ts loaded. Mocking backend calls until canisters are deployed and declarations generated.");
